------------------ MODULE CommCell ---------------------
(*https://elixir.bootlin.com/linux/v4.2/source/drivers/tty/serial/serial_core.c*)
(*http://www.modbus.org/docs/Modbus_over_serial_line_V1.pdf*)

EXTENDS Sequences
isValidModbus(str) == TRUE
(*
(*
--algorithm RxTx
{
    \*tx if there is something to send, rx if there is something to receive
   variables 
        isIdle = TRUE,
        txBuff = "",
        rxBuff = "",
        startMsg = ":", 
        end1="CR",
        end2="LF",
        tx = FALSE, \*set by application if the buffer contains a message to send
        rx = FALSE, \* set by code below when we've received a full, valid frame ready to be processed
        txReg \in 0 ..255,
        rxReg \in 0 .. 255,
        rxBuffCount = 0;
        txBuffCount = 0,
        isValidCRC = TRUE;
            
    \* Station is idle
    \* can rx or tx
    \* tx ---------------------------------
    
    process (Serial = "Serial")
    {
        idle: while (TRUE)
        {
            isIdle := TRUE;
            \*if we have something to send and we are not receiving
            \*and if the buffer contains a valid Modbus frame (TODO)
            switchToTx: if(tx = TRUE && txBuffCount \= 0 && isValidModbus(txBuff))
            { 
                \* we are no longer idle, put the start message 
                \* character, ";", into the send transmit register
                emission_start: isIdle  := FALSE;
                                txReg   := startMsg;
                \* while there is stuff to send, keep sending it byte by byte
                emission:   while ( l1: txBuffCount \= 0)
                            { 
                                l2: txReg := txBuff;
                                    txBuffCount := txBuffCount -1;
                            };
                \* when the register is empty send the CR/LF and go back to idle
                emission_end: txReg := end1;
                backToIdle: txReg := end2;
                              tx := FALSE;
                              goto idle;
            };
            \* if we are receiving something (there is a ":" in the rx register)
            switchToRx: if(rxReg = startMsg)
            {
                \*init reception: set idle to false, reset the receive buffer counter
                reception:  isIdle := FALSE;
                            r1: rxBuff := <<>>;
                            r2: rxBuff := rxBuff \o rxReg;
                            rxBuffCount := 1;
                            \* if at any point before the message is complete we get another ":"
                            \* restart the process
                            r3: if(rxReg = startMsg) {goto reception}; \*can receive ":" multiple times
                            \*loop until we get the end of the message
                            r4: while( rxReg \= "CR" )
                                {
                                    if(rxReg = startMsg) {goto reception; };
                                    r5: rxBuffCount := rxBuffCount + 1;
                                        rxBuff[rxBuffCount] := rxReg;
                                };
                            \*handle end of frame, check if valid modbus (TODO)
                            \*handle CRC (TODO)
                endFrame:   if(rxReg = startMsg) { goto reception; };
                            r6: if(rxReg = end2 && isValidModbus(rxBuff))
                                {
                                \*if we get LF\CR and the CRC is good and the frame is valid modbus
                                \*then signal to the application that the rx buffer is ready to process
                                    rx := TRUE;
                                };
                            
                            
            };
        };          
    }                            
     

    
}
*)
*)


==============================================================
